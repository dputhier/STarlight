---
title: "Guided tutorial"
author: "D. Puthier"
date: "2024-03-06"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::knitr}
  %\VignetteIndexEntry{Guided tutorial}
  %\usepackage[UTF-8]{inputenc}
  html_document:
  fig_caption: yes
  highlight: zenburn
  theme: cerulean
  toc: no
  toc_depth: 3
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  fig.align = "center" 
)
```

<style>
body {
text-align: justify}
</style>

# Overview

Spatial transcriptomics (ST) enables researchers to spatially resolved gene expression within tissue sections, providing valuable insights into the spatial organization of cells and biological processes. Cell segmentation followed by transcript partitioning are generally the first steps performed when analyzing imaging-based ST data. This approach can be tricky for a number of reasons, including high cell density and oftentimes complex cell shapes as well as the absence or poor quality of surface labeling. Consequently, cell segmentation is often performed in sparse areas, but this prevents researchers from spatially resolving tissue architecture at the global scale

The `STarlight` package is an R package for cell segmentation-free analysis of imaging-based spatial transcriptomics data (*e.g.* Merscope, Xenium or CosMx). It leverages a grid-based approach that bypasses cell-segmentation, facilitating exploratory analysis and multi-sample comparisons.  

# Loading libraries

```{r loading1, echo=FALSE, eval=TRUE, warning=FALSE, results='hide'}
suppressMessages(suppressWarnings(library(magrittr, quietly = TRUE)))
suppressMessages(suppressWarnings(library(Seurat, quietly = TRUE)))
suppressMessages(suppressWarnings(library(STarlight, quietly = TRUE)))
STarlight::set_verb_level(0)
suppressMessages(suppressWarnings(library(patchwork, quietly = TRUE)))
suppressMessages(suppressWarnings(library(ggplot2, quietly = TRUE)))
suppressMessages(suppressWarnings(library(dplyr, quietly = TRUE)))
```

```{r loading2, echo=TRUE, eval=FALSE}
library(magrittr)
library(Seurat)
library(STarlight)
STarlight::set_verb_level(0)
library(patchwork)
library(ggplot2)
library(dplyr)
```

# Retrieving the dataset

We are going to be using a subset (64 genes) of a 10x Genomics dataset taken from the Xenium Explorer Demo. The region corresponds to a fresh frozen mouse brain coronal section. The original dataset can be downloaded [here](https://www.10xgenomics.com/resources/datasets/fresh-frozen-mouse-brain-for-xenium-explorer-demo-1-standard). 


```{r}
## create a temporary folder
tmpdir <- tempdir()
dir.create(tmpdir, showWarnings = FALSE)
remote_file <- "Xenium_Mouse_Brain_Coronal_tiny.csv.gz"
## Download and unzip the file
url_data <- paste0("https://zenodo.org/records/11371819/files/",
                   remote_file)
dest_file <- file.path(tmpdir, remote_file)
download.file(url_data, destfile = dest_file)

```

# Loading the data

The `load_spatial()` function is the entry point of the `STarlight` package. It allows you to load molecule coordinates and create a 2D binned grid (default size of 25Âµm). Since we are working with a csv flat file containing x/y coordinates and gene names we do not need to specify the argument `method`. If you have access to the full Xenium directory, you can use the arguments `method="xenium"` and `path="path/to/directory"` to load the data.


```{r loadfile}
st_obj <- load_spatial(path = dest_file, 
             method = "coordinates", 
             sep=",", 
             mapping = c(feature="feature_name", 
                         x="x_location", 
                         y="y_location"), 
                         bin_size = 25, 
            control = "(NegControl)|(^BLANK)", verbose = FALSE)
```

## Side note

Using the argument `control` in the `load_spatial` function above allows users to directly remove the blank/control probes from their data before creating the binned grid. If users choose to keep this information, the probes can later be removed via the following. 

```{r delete, echo = TRUE, eval=TRUE, warning=FALSE, results='hide'}
st_obj <- rm_controls(st_obj)
```

# The STGrid object

The Spatial Transcriptomic Grid class (STGrid) is a structured framework for managing and analyzing your data. It facilitates the exploration and interpretation of spatial gene expression patterns within tissue sections.

```{r show, echo = TRUE, eval=TRUE, warning=FALSE, results='hide'}
STarlight::set_verb_level(1)
st_obj
```
Here are the slots contained in the object.

```{r slots, echo = TRUE, eval=TRUE, warning=FALSE, results='hide'}
slotNames(st_obj)
```
Multiple methods are supported by the STGrid object. 

```{r show_st_methods, echo = TRUE, eval=TRUE, warning=FALSE, results='hide'}
STarlight::show_st_methods()
```

## Subsetting

We've made it easy for users to subset data in their STGrid object using the "[" operator. This is designed to facilitate the extraction of specific genes or regions for a more focused analysis.

### Subsetting using bin_x / bin_y

We can explore the binning information stored within our STGrid object using `bin_x()` and `bin_y()`. Let's take a look at the first few entries of the bin_x and bin_y vectors:

This command retrieves the first few entries of the bin_x vector (bins along the x-axis).
```{r binx_1, echo = TRUE, eval=TRUE, warning=FALSE, results='hide'}
head(bin_x(st_obj))
```

Similarly, this command retrieves the first few entries of the `bin_y` vector (bins along the y-axis).
```{r binx_2, echo = TRUE, eval=TRUE, warning=FALSE, results='hide'}
head(bin_y(st_obj))
```

We can leverage the subsetting function to extract data corresponding to specific bins along the x-axis (i.e. bins from the 50th to the 100th entry of the bin_x vector). The following command extracts a subset of the data and saves it to a new STGrid object.

```{r binx_3, echo = TRUE, eval=TRUE, warning=FALSE, results='hide'}
subset <- st_obj[bin_x(st_obj)[50:100], ]
```

### Subsetting using genes

We can also extract data associated to specific genes from our STGrid object using the subsetting operator. Here we extract data corresponding to the genes "Chat" and "Cbln4":

```{r genes, echo = TRUE, eval=TRUE, warning=FALSE, results='hide'}
st_obj[c("Chat", "Cbln4"), ]
```

### Subsetting using numeric indices

We can retrieve data based on the position of genes within the `feat_names()` vector of our STGrid object. Let's extract data for the first 10 genes according to their position in the `feat_names()` vector:

```{r numerics_1, echo = TRUE, eval=TRUE, warning=FALSE, results='hide'}
st_obj[feat_names(st_obj)[1:10], ]
```

Users can also explore data for the 10th to 12th genes using numeric indices. We first start by determining the total number of genes in our STGrid object:

```{r numerics_2, echo = TRUE, eval=TRUE, warning=FALSE, results='hide'}
nb_feat(st_obj)
```

We then retrieve data for genes positioned 10 through 12 in the `feat_names()` vector.

```{r index_10_12, echo = TRUE, eval=TRUE, warning=FALSE, results='hide'}
st_obj[10:12, ]
```

## Image Visualization

### The spatial_image() function

The `spatial_image()` function allows for the visualization of the density of spatial molecules across the tissue section. The following examples demonstrate the visualization of a single gene. The grid=TRUE argument allow to show bin numbering in x and y dimension. This eases the selection of particular regions.

```{r single_gene, warning=FALSE, results='hide', echo = FALSE, eval=TRUE}
spatial_image(st_obj, feat="Ano1", grid = 20, 
              logb = 10, scale = TRUE, saturation = 0.9)
```

One can **zoom** for instance in the region with high "Ano1" molecule density in the upper right corner of the previous image. Here we use `rebin()` to increase the resolution specifically on "Ano1".

```{r zoom}
x_bins <-  bin_x(st_obj)[181:nbin_x(st_obj)]
y_bins <-  bin_y(st_obj)[101:nbin_y(st_obj)]
st_obj_r1 <- st_obj[x_bins, y_bins]
spatial_image(re_bin(st_obj_r1[c("Ano1", "Chat"),], bin_size = 5, verbose = FALSE), 
              feat=c("Ano1", "Chat"), logb = 10,
              scale = TRUE, saturation = 0.9)
```

### The spatial_plot() function

The `spatial_plot()`function is intented to create a scatter plot of molecule x/y coordinates. We may for example highlight other molecules with same pattern as "Ano1"

```{r spatial_plot}
spatial_plot(st_obj[x_bins, y_bins], feat_list = c("Ano1", 
                                                     "Chat",
                                                     "Ebf3"), 
             colors = ggsci::pal_aaas()(3),
             size=1)
```

# Searching modules

The hc_tree() allow to organize genes into subclusters.

```{r spatial_plot_2}
hc_st <- hc_tree(st_obj, method = "ward.D", 
                 layout = "circular", dist_method = "pearson",
                 class_nb = 20)
hc_st
```

```{r}
# The first 3 modules
hc_st$tree_classes[1:3]
```

Computing average module score:

```{r}
st_obj <- compute_module_score(st_obj, modules = hc_st$tree_classes)
meta_names(st_obj)
```
```{r}
spatial_image(st_obj, features = meta_names(st_obj))
```

```{r}
spatial_image(st_obj, features = hc_st$tree_classes[["MOD07"]])
```


# Molecule clustering

## K Ripley's function

We may use the K-Ripley's function to assess the level of clustering of each molecules in the two regions. Not that this step is rather long as the density of molecule increases. For the tutorial will thus concentrate on few genes.

```{r compute_k_ripley}
gene_list <- c("Chat", "Spag16", "Tacr1", "Sncg", feat_names(st_obj)[1:10])
plot_rip_k(compute_k_ripley(st_obj, rmax = 80, verbose = FALSE))
```


```{r}
spatial_image(st_obj, features = c("Chat", "Spag16", "Tacr1", "Nwd2"))
```

# Comparing counts

The stcompr() function is used to compare two sets of data. By way of illustration, and to limit the calculation time required for this vignette, we will use this function to compare two regions of the organ, which will be considered here as two conditions. Still for illustration purpose, we will generate two replicates per conditions/regions (in fact two close regions)


```{r STarlight}
## "Conditions 1"
# "replicate 1"
x_bins <-  bin_x(st_obj)[180:nbin_x(st_obj)]
y_bins <-  bin_y(st_obj)[100:nbin_y(st_obj)]
st_obj_r1_1 <- st_obj[x_bins, y_bins]

# "replicate 2"
x_bins <-  bin_x(st_obj)[170:200]
y_bins <-  bin_y(st_obj)[90:130]
st_obj_r1_2 <- st_obj[x_bins, y_bins]


## "Conditions 2"
# "replicate 1"
x_bins <-  bin_x(st_obj)[60:100]
y_bins <-  bin_y(st_obj)[100:nbin_y(st_obj)]
st_obj_r2_1 <- st_obj[x_bins, y_bins]

# "replicate 2"
x_bins <-  bin_x(st_obj)[50:90]
y_bins <-  bin_y(st_obj)[80:130]
st_obj_r2_2 <- st_obj[x_bins, y_bins]
```

Here is our illustrative dataset visualized using the *cmp_images()* function:

```{r}
cmp_images(st_obj_r1_1,
           st_obj_r1_2,
           st_obj_r2_1, 
           st_obj_r2_2,
           feat_list="count_sum",
           names=c("region_1_1", "region_1_2", "region_2_1", "region_2_2"),
           color_y_strip=c("pink", "pink", "lightblue", "lightblue"),
           color_strip_text_y = "black",
           color_x_strip="#333333",
           colors = viridis::magma(10)
           )
```
And the count distribution for each replicate:

```{r}
dist_st(st_obj_r1_1,
           st_obj_r1_2,
           st_obj_r2_1, 
           st_obj_r2_2,
           transform = "log10")
```


## Creating an STCompR object

Now we can create an STCompR object using the stcompr() function. 

```{r STarlight_create}
cmp <- stcompr(list(st_obj_r1_1,
                    st_obj_r1_2),
                list(st_obj_r2_1, 
                    st_obj_r2_2), 
               name_1="region_1", name_2="region_2")
```

## Count distributions

Here are the normalized counts:

```{r cmp_boxplot}
cmp_boxplot(cmp, transform = "log10", normalized = TRUE)
```

## Count comparison

As we can see below the two regions differ in the expression levels of several genes.

```{r cmp_volcano}
cmp_volcano(cmp, text_y_lim = 20, text_size = 2, text_x_lim = 2.5)
```

We may check the differential expression of these genes using the `cmp_images()` function:

```{r}
markers <- cmp@stat_test %>% 
              dplyr::filter(abs(log2_ratio) > 2.5) %>% 
              dplyr::arrange(log2_ratio) %>%  
              dplyr::filter(-log10(p_values) > 20) %>% rownames()

cmp_images(st_obj_r1_1,
           st_obj_r1_2,
           st_obj_r2_1, 
           st_obj_r2_2,
           feat_list=markers,
           names=c("region_1_1", "region_1_2", "region_2_1", "region_2_2"),
           color_y_strip=c("pink", "pink", "lightblue", "lightblue"),
           color_strip_text_y = "black",
           color_x_strip= c("darkgreen", "darkgreen", "darkred", "darkred", "darkred"),
           colors = viridis::magma(10))
```





